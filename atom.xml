<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>joyo</title>
  
  <subtitle>死亡是人生中最伟大的发明.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hushizhi.github.io/"/>
  <updated>2019-09-21T09:37:45.191Z</updated>
  <id>https://hushizhi.github.io/</id>
  
  <author>
    <name>戚灼伟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工程方法 - CI/CD</title>
    <link href="https://hushizhi.github.io/uncategorized/2019/09/14/CI%E4%B8%8ECD.html"/>
    <id>https://hushizhi.github.io/uncategorized/2019/09/14/CI与CD.html</id>
    <published>2019-09-14T11:28:47.000Z</published>
    <updated>2019-09-21T09:37:45.191Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>&emsp;&emsp;在比较小且快速的迭代开发过程中，持续验证系统的开发成果，小步快跑式地尽早确认，期望开发尽可能完全符合原始需求，或者依据产出进行快速修正。<br><br>&emsp;&emsp;简单地说，是尽量减少人力手动操作，将一些日常工作交给机器进行自动化处理。如环境配置、单元测试、日志记录、打包部署等。<br><br>&emsp;&emsp;一切业务的更替发展必须建立在稳定性的基础上。业务 RD 是平台服务的搭建者，书写出无 bug 的代码是夯实稳定性根基的重要手段。<br><br>&ensp;&ensp;&ensp;根据以往经验，开发流程中经常会出现如下问题：</p><ul><li>RD 更为关注的是具体功能实现，往往容易忽略代码质量以及单测的重要性。</li><li>以往 case 中，大概 70% 的线上 bug 都是因为代码质量问题导致。</li><li>单测维护成本较高，存量覆盖耗时费力。</li><li>单测流程不规范，新增逻辑往往忽略单测的维护。</li></ul><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>降低风险：业务稳定性为核心目标。</li><li>减少人工手动操作的繁琐程序。</li><li>减少逻辑代码千行bug率。</li><li>通过单测提前暴露问题，降低返工率，提高研发效率。</li><li>能随时发版打包出可发布部署的版本。</li></ul><h2 id="CI-CD-工作原理"><a href="#CI-CD-工作原理" class="headerlink" title="CI/CD 工作原理"></a>CI/CD 工作原理</h2><ol><li><strong>持续集成（Continuous Integration）</strong></li></ol><blockquote><p>指开发人员在特定分支（频繁）提交代码后，立即执行构建和单元测试，代码通过测试标准后集成到主干的过程。强调的是分支代码的提交、构建与单元测试，这个过程的产出是单元测试报告。</p></blockquote><p>持续集成指的是，频繁地（一天多次）将代码集成到主干。<br>持续集成的目的，就是让产品快速迭代，同时还能保持高质量。<br>它的核心措施是，代码集成到主干之前，必须通过自动化测试，只要有一个测试用例失败，就不能集成。</p><p><img src="https://i.loli.net/2019/09/14/fGQ7lCKRPyoc3pt.png" width="400" height="200"></p><ol><li><strong>持续交付（Continuous Delivery）</strong></li></ol><blockquote><p>是在<strong>持续集成</strong>的基础上，将构建的代码部署到「类生产环境」，完成QA测试过程之后<strong>手动部署</strong>到生成环境的过程。强调代码部署，这个过程产出测试报告。</p></blockquote><p>频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。持续交付可以看成是持续集成的下一步，它强调的是，不管怎么更新，软件是随时随地可以交付的。</p><p><img src="https://i.loli.net/2019/09/14/VsbJywcHPN78h3m.png" width="400" height="300"></p><ol start="3"><li><strong>持续部署（Continuous Deployment）</strong></li></ol><blockquote><p>是持续交付的下一步，强调部署生产环境代码的过程<strong>自动化</strong>，同时可以处理上线通知等操作。</p></blockquote><p>持续部署是持续交付的下一步，指的是代码通过评审后，自动地部署到生产环境。持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。</p><p><img src="https://i.loli.net/2019/09/14/xPkvVNCKwJTDMaq.png" width="400" height="300"></p><h4 id="根据以上是3个步骤的循环迭代，就可以针对每个软件系统每次代码变动，持续自动地进行验证。这些验证包括以下方面"><a href="#根据以上是3个步骤的循环迭代，就可以针对每个软件系统每次代码变动，持续自动地进行验证。这些验证包括以下方面" class="headerlink" title="根据以上是3个步骤的循环迭代，就可以针对每个软件系统每次代码变动，持续自动地进行验证。这些验证包括以下方面"></a>根据以上是3个步骤的循环迭代，就可以针对每个软件系统每次代码变动，持续自动地进行验证。这些验证包括以下方面</h4><pre><code>1. Build2. Test3. Source Code Analysis4. Auto Deployment</code></pre><h4 id="通过这个流程，可以确保软件质量，不会因为一个变动而产生错误甚至崩溃。同时，流程的最后会产出一些质量报告，用做后续分析并发现软件中仍然潜在的问题"><a href="#通过这个流程，可以确保软件质量，不会因为一个变动而产生错误甚至崩溃。同时，流程的最后会产出一些质量报告，用做后续分析并发现软件中仍然潜在的问题" class="headerlink" title="通过这个流程，可以确保软件质量，不会因为一个变动而产生错误甚至崩溃。同时，流程的最后会产出一些质量报告，用做后续分析并发现软件中仍然潜在的问题"></a>通过这个流程，可以确保软件质量，不会因为一个变动而产生错误甚至崩溃。同时，流程的最后会产出一些质量报告，用做后续分析并发现软件中仍然潜在的问题</h4><h2 id="工具的选择"><a href="#工具的选择" class="headerlink" title="工具的选择"></a>工具的选择</h2><p>作为工作流中不可或缺的一环，CI 系统的目标是打造集 iOS 应用测试，集成，测试与打包为一体的平台，支撑 iOS 应用的质量保障及持续交付。</p><p>主要有以下 3 中工具：老牌的 Jenkins，插件齐全的 MCI， Hyperloop。</p><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><p>&emsp;&emsp;Jenkins 是一个基于 JAVA 、开源的持续集成平台。Jenkins 的一个强大之处是支持插件，所以可以按需扩展出各种各样的功能，形成独特的平台。<br><br>&emsp;&emsp;一个集群由一台 master 及数台 slave 组成， slave 可以有多个 executor 用于执行 job，job 可以是构建，单测，管理 slave 等。<br><br>&emsp;&emsp;Jenkins的功能完整，也提供了上千個插件 (Plugins) 來应对各种开发语言和工具。Jenkins 目前已发展到了 2.x 版，新版本中对于 Pipeline 概念及容器 (Container) 整合也趋于完整，是一套可以自定义运行的系統。但也因為其功能強大、可定制程度高，上手使用需要一些时间。然而一旦流程被定义好，并整合好相关环境，它就可以发挥持续整合的威力，大幅提高开发生产力。</p><h4 id="运作流程"><a href="#运作流程" class="headerlink" title="运作流程"></a>运作流程</h4><h6 id="构建（以单测为例）"><a href="#构建（以单测为例）" class="headerlink" title="构建（以单测为例）"></a>构建（以单测为例）</h6><p><img src="https://i.loli.net/2019/09/21/MhezwJDFZv4QdNm.png" width="400" height="300"></p><h5 id="打包（以-beta-版本为例）"><a href="#打包（以-beta-版本为例）" class="headerlink" title="打包（以 beta 版本为例）"></a>打包（以 beta 版本为例）</h5><p><img src="https://i.loli.net/2019/09/21/AkcWglZVe2NfuP7.png" width="400" height="300"></p><h3 id="MCI"><a href="#MCI" class="headerlink" title="MCI"></a>MCI</h3><h3 id="Hyperloop"><a href="#Hyperloop" class="headerlink" title="Hyperloop"></a>Hyperloop</h3><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在比较小且快速的
      
    
    </summary>
    
    
      <category term="CI/CD" scheme="https://hushizhi.github.io/tags/CI-CD/"/>
    
  </entry>
  
  <entry>
    <title>ARC 与 MRC</title>
    <link href="https://hushizhi.github.io/uncategorized/2019/09/14/ARC-%E4%B8%8E-MRC.html"/>
    <id>https://hushizhi.github.io/uncategorized/2019/09/14/ARC-与-MRC.html</id>
    <published>2019-09-14T09:32:52.000Z</published>
    <updated>2019-09-14T09:39:48.588Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="ARC-与-MRC-的区别"><a href="#ARC-与-MRC-的区别" class="headerlink" title="ARC 与 MRC 的区别"></a>ARC 与 MRC 的区别</h3><ol><li>相同点：均是 Objective-C 使用引用计数管理内存的方式；其中 MRC 是手动引用计数，ARC 是自动引用计数。</li><li><p>区别：ARC 相对 MRC 来说，不需要手动输入retain/release/autorelease,而是在编译期和运行期这两部分帮助开发者管理内存。<br>在编译期期间，ARC自动调用C接口实现在编译代码时自动插入retain/release/autorelease;在运行期期间，使用 runtime 配合来管理内存。</p><a id="more"></a></li><li><p>Autorelease: 即添加到自动释放池中。自动释放分为两种情况：</p><ol><li>手动干预释放时机：指定autoreleasepool，就是所谓的作用域大括号结束释放；</li><li>系统自动释放：不手动指定autoreleasepool。autorelease对象出了作用域后，会被自动添加到最近一次创建的自动释放池中，并会在当前runloop迭代结束之后释放。</li></ol></li><li>runloop与autorelease:<ol><li>runloop从程序启动到加载完成是一个完整的运行循环，然后会停下来，等待用户交互，用户的每一次交互都会启动一次运行循环，这时候回创建自动释放池，来处理用户所有的点击、交互事件，在一次完整的运行循环结束之前，会销毁自动释放池，达到销毁对象的目的。</li></ol></li></ol><h3 id="引用计数-与-GC-的区别"><a href="#引用计数-与-GC-的区别" class="headerlink" title="引用计数 与 GC 的区别"></a>引用计数 与 GC 的区别</h3><p>待补充。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ARC-与-MRC-的区别&quot;&gt;&lt;a href=&quot;#ARC-与-MRC-的区别&quot; class=&quot;headerlink&quot; title=&quot;ARC 与 MRC 的区别&quot;&gt;&lt;/a&gt;ARC 与 MRC 的区别&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;相同点：均是 Objective-C 使用引用计数管理内存的方式；其中 MRC 是手动引用计数，ARC 是自动引用计数。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;区别：ARC 相对 MRC 来说，不需要手动输入retain/release/autorelease,而是在编译期和运行期这两部分帮助开发者管理内存。&lt;br&gt;在编译期期间，ARC自动调用C接口实现在编译代码时自动插入retain/release/autorelease;在运行期期间，使用 runtime 配合来管理内存。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://hushizhi.github.io/tags/iOS/"/>
    
      <category term="内存管理" scheme="https://hushizhi.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>怎么忽略断言NSAssert</title>
    <link href="https://hushizhi.github.io/uncategorized/2019/07/17/%E6%80%8E%E4%B9%88%E5%BF%BD%E7%95%A5%E6%96%AD%E8%A8%80NSAssert.html"/>
    <id>https://hushizhi.github.io/uncategorized/2019/07/17/怎么忽略断言NSAssert.html</id>
    <published>2019-07-17T01:26:27.000Z</published>
    <updated>2019-09-14T07:08:06.555Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p class="description"></p><p><img src="https://" alt style="width:100%"></p><a id="more"></a><p>##</p><p>##</p><p>##</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://&quot; alt style=&quot;width:100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://hushizhi.github.io/tags/iOS/"/>
    
      <category term="Debug" scheme="https://hushizhi.github.io/tags/Debug/"/>
    
  </entry>
  
  <entry>
    <title>编程范式思维</title>
    <link href="https://hushizhi.github.io/uncategorized/2018/12/01/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%80%9D%E7%BB%B4.html"/>
    <id>https://hushizhi.github.io/uncategorized/2018/12/01/编程范式思维.html</id>
    <published>2018-12-01T15:31:04.000Z</published>
    <updated>2018-12-01T15:36:47.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p class="description"></p><p>程序设计有一个范式问题：就是组织程序的基本思想。它反映了程序设计者对程序的一个基本的哲学观，也就是说，他认为程序的本质是什么，他认为一个大的程序是由什么组成的。</p><p>范式目前有三种：过程范式、函数范式、对象范式。</p><p><img src="https://" alt style="width:100%"></p><a id="more"></a><ol><li>过程范式认为，程序是由一个个过程经过顺序、选择和循环的结构组合而成。反映在现实世界，过程范式体现了劳动分工之前“大包大揽”的工作特点—能胜任所有事情，拥有所有的资源，高度集中在这个“人”身上，只不过具体的事情得一步步地有顺序来处理。</li><li>对象范式反映了劳动分工之后的团队协作的工作特点–每个人各司其职，各有所长，各自拥有私有资源，工件和信息彼此传递，最后完成工作。因此，对象范式也就形成了自己对程序的看法—程序是由一组对象组成，这些对象各有所能，通过消息传递实现协作。</li></ol><p>后者较前者具有3个优势：</p><ol><li>由于实现了逻辑分工，降低了大规模程序的开发难度。</li><li>灵活性更好–若干对象在一起，可以灵活组合，可以以不同的方式协作，完成不同的任务，也可以灵活的替换和升级。</li><li>对象范式更加适合图形化、网络化、消息驱动的现代计算环境。</li></ol><p>对象范式的两大基本观念：</p><ul><li>程序是由对象组成的。</li><li>对象之间互相发送消息，协作完成任务。</li></ul><p>为了方便对象的构造，引入了类、继承等概念。 smalltalk构造了更灵活和纯粹的消息发送机制。</p><p>它实现了一个与目标对象无关的消息发机制，不管那个对象是谁，也不管他是不是能正确的处理一个消息，作为发送消息的对象来说，可以毫无顾忌的抓住一个对象就发送消息过去。接到消息的对象，要尝试理解这个消息，并最后调用自己的处理过程来处理消息。如果这个消息能被处理，那个对象自然会处理，如果不能处理，Smalltalk系统会向消息的发送者回传一个doesNotUnderstand消息，予以通知。对象不用关心消息是如何传递格给一个对象的，传递过程被分离出来（而不是向Simula那样明确地以成员函数调用的方式实现），可以是在内存中复制，也可以是进程间通讯。到了Smalktalk-80，消息传递甚至可以跨越网络。</p><p>不妨把源自Smalktalk的消息机制称为“动态消息机制”。</p><p>把源自Simula的消息机制称为“静态消息机制”。</p><p>对于消息转发机制的不同选择，主要是因为用途。Simula用于仿真程序开发，smalltalk用于图形界面环境构建。</p><p>到了1980年代，C出现了。Bjarne Stroustrup在博士期间深入研究Simula，于是在C语言基础上，几乎把Simula思想照搬过来，形成了最初的C。 大约在同期，Brad Cox根据Smalltalk的思想设计了Objective-C，可是由于其语法怪异，没有流行起来。只有Steve Jobs这种具有禅宗美学鉴赏力的世外高人，于1988年把Objective-C的团队和产品一口气买了下来。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;程序设计有一个范式问题：就是组织程序的基本思想。它反映了程序设计者对程序的一个基本的哲学观，也就是说，他认为程序的本质是什么，他认为一个大的程序是由什么组成的。&lt;/p&gt;
&lt;p&gt;范式目前有三种：过程范式、函数范式、对象范式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://&quot; alt style=&quot;width:100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程思考" scheme="https://hushizhi.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>善良的力度</title>
    <link href="https://hushizhi.github.io/uncategorized/2018/06/04/%E5%96%84%E8%89%AF%E7%9A%84%E5%8A%9B%E5%BA%A6.html"/>
    <id>https://hushizhi.github.io/uncategorized/2018/06/04/善良的力度.html</id>
    <published>2018-06-04T06:35:39.000Z</published>
    <updated>2018-06-04T06:50:12.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>一对夫妻很幸运地订到了火车票，上车后却发现有位女士坐在她们的位子上，先生示意太太坐在她旁边的位子上，却没有请那位女士让位。太太坐定后仔细一看，发现哪位女士右脚有点不方便，才了解先生为何不请她起来。他就这样从嘉义一直站到台北。<br>下了车之后，心疼先生的太太就说：“让位是善行，但从嘉义到台北这么久，中途大可请她把位子还给你，换你坐一下。”<br>先生却说：“人家不方便一辈子，我们就不方便这3小时而已。”太太听了相当感动，觉得世界都变得温柔很多。<br>“人家不方便一辈子，我们就不方便3小时而已。”多浩荡大气、慈悲善美的一句话，它能将善念传导给别人，影响周遭的环境氛围，让世界变得善美、圆满。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;一对夫妻很幸运地订到了火车票，上车后却发现有位女士坐在她们的位子上，先生示意太太坐在她旁边的位子上，却没有请那位女士让位。太太坐定后仔细一看，发现哪位女士右脚有点不方便，才了
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>支持度，提升度，置信度</title>
    <link href="https://hushizhi.github.io/uncategorized/2018/05/18/%E6%94%AF%E6%8C%81%E5%BA%A6%EF%BC%8C%E6%8F%90%E5%8D%87%E5%BA%A6%EF%BC%8C%E7%BD%AE%E4%BF%A1%E5%BA%A6.html"/>
    <id>https://hushizhi.github.io/uncategorized/2018/05/18/支持度，提升度，置信度.html</id>
    <published>2018-05-18T01:15:16.000Z</published>
    <updated>2018-06-04T06:50:09.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p class="description"></p><p><img src="https://" alt style="width:100%"></p><a id="more"></a><p>Reference：关联分析中的支持度、置信度和提升度</p><p>1.支持度（Support）<br>支持度表示项集 (X,Y)(X,Y) 在总项集里出现的概率。公式为：</p><p>Support(X→Y)=P(X,Y)P(I)=P(X∪Y)P(I)=num(X∪Y)num(I)<br>Support(X→Y)=P(X,Y)P(I)=P(X∪Y)P(I)=num(X∪Y)num(I)<br>其中，num(I)num(I) 表示总事务集的个数， num(X∪Y)num(X∪Y) 表示含有 {X,Y}{X,Y} 的事务集的个数（个数也叫次数）。</p><p>2.置信度（Confidence）<br>置信度表示在先决条件X发生的情况下，由关联规则 X→YX→Y 推出 YY 的概率。即在含有 XX 的项集中，含有 YY 的可能性，公式为：</p><p>Confidence(X→Y)=P(Y|X)=P(X,Y)P(X)=P(X∪Y)P(X)<br>Confidence(X→Y)=P(Y|X)=P(X,Y)P(X)=P(X∪Y)P(X)<br>3.提升度（Lift）<br>提升度表示含有 XX 的条件下，同时含有 YY 的概率，与不含 XX 的条件下却含 YY 的概率之比。</p><p>Lift(X→Y)=P(Y|X)P(Y)<br>Lift(X→Y)=P(Y|X)P(Y)<br>例1，已知有1000名顾客买年货，分为甲乙两组，每组各500人，其中甲组有500人买了茶叶，同时又有450人买了咖啡；乙组有450人买了咖啡.</p><p>试求解</p><p>1）“茶叶→→咖啡”的支持度</p><p>2）“茶叶→→咖啡”的置信度</p><p>3）“茶叶→→咖啡”的提升度</p><p>分析：</p><p>设 X={买茶叶}X={买茶叶} ，Y={买咖啡}Y={买咖啡}，则规则 “茶叶→→咖啡” 表示 “即买了茶叶，又买了咖啡”，于是，“茶叶→→咖啡”的支持度为</p><p>Support(X→Y)=450/500=90%Support(X→Y)=450/500=90%<br>“茶叶→→咖啡”的置信度为</p><p>Confidence(X→Y)=450/500=90%Confidence(X→Y)=450/500=90%<br>“茶叶→→咖啡”的提升度为</p><p>Lift(X→Y)=Confidence(X→Y)P(Y)=90%((450+450)/1000)=90Lift(X→Y)=Confidence(X→Y)P(Y)=90%((450+450)/1000)=90<br>由于提升度 Lift(X→Y)=1Lift(X→Y)=1，表示 XX 与 YY 相互独立，即是否有 XX，对于 YY 的出现无影响。也就是说，是否购买咖啡，与有没有购买茶叶无关联。即规则“茶叶→→咖啡”不成立，或者说关联性很小，几乎没有，虽然它的支持度和置信度都高达90%，但它不是一条有效的关联规则。</p><p>满足最小支持度和最小置信度的规则，叫做“强关联规则”。然而，强关联规则里，也分有效的强关联规则和无效的强关联规则。</p><p>如果Lift(X→Y)&gt;1Lift(X→Y)&gt;1，则规则X→YX→Y是有效的强关联规则。</p><p>如果Lift(X→Y)&lt;=1Lift(X→Y)&lt;=1，则规则 X→YX→Y是无效的强关联规则。</p><p>特别地，如果Lift(X→Y)=1Lift(X→Y)=1，则表示 XX 与 YY 相互独立。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://&quot; alt style=&quot;width:100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Apriori" scheme="https://hushizhi.github.io/tags/Apriori/"/>
    
      <category term="机器学习" scheme="https://hushizhi.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法入门</title>
    <link href="https://hushizhi.github.io/uncategorized/2018/05/09/Markdown%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8.html"/>
    <id>https://hushizhi.github.io/uncategorized/2018/05/09/Markdown语法入门.html</id>
    <published>2018-05-09T15:55:32.000Z</published>
    <updated>2018-12-01T15:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p class="description"></p><p><img src="https://" alt style="width:100%"></p><a id="more"></a><p>##</p><p>##</p><p>##</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://&quot; alt style=&quot;width:100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>毕业季前50天</title>
    <link href="https://hushizhi.github.io/%E6%9D%82%E8%AE%B0/2018/05/09/%E6%AF%95%E4%B8%9A%E5%AD%A3%E5%89%8D50%E5%A4%A9.html"/>
    <id>https://hushizhi.github.io/杂记/2018/05/09/毕业季前50天.html</id>
    <published>2018-05-09T15:10:41.000Z</published>
    <updated>2019-09-15T03:02:29.623Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"http://p8gu1ztx5.bkt.clouddn.com/Beyond%20-%20%E3%80%8A%E6%9B%BE%E6%98%AF%E6%8B%A5%E6%9C%89%E3%80%8B.mp4","pic":"http://p8gu1ztx5.bkt.clouddn.com/beyond.jpeg"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>致谢<br>   时光飞逝，岁月如梭。论文行文至此，四年本科大学时光匆匆如雨夜前的行人，突觉不舍与伤感。眺望往日，与三五同学篮球场挥舞汗水的身姿，挤在同一个实验室敲打键盘讨论学习的年少轻狂，欢声畅聊的东门小吃街对酒当歌，一幕幕恍如昨天，涌上心头。</p>   <a id="more"></a><p>   二十年的求学路，一路走来，一路含泪挥手离家，一路风尘仆仆归去，父母亲的白发如脑中所习得的油墨，渐行渐长；百感交集的此刻，更多是对过往沿途的怀恋，充满着感激，满怀的欣喜与感恩。</p><p><img src="http://p8gu1ztx5.bkt.clouddn.com/image/jpg%E4%B8%8D%E8%83%BD%E8%AF%B4%E7%9A%84%E7%A7%98%E5%AF%86.jpg" alt></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;dplayer0&quot; class=&quot;dplayer hexo-tag-dplayer-mark&quot; style=&quot;margin-bottom: 20px;&quot;&gt;&lt;/div&gt;&lt;script&gt;(function(){var player = new DPlayer({&quot;container&quot;:document.getElementById(&quot;dplayer0&quot;),&quot;theme&quot;:&quot;#FADFA3&quot;,&quot;loop&quot;:true,&quot;video&quot;:{&quot;url&quot;:&quot;http://p8gu1ztx5.bkt.clouddn.com/Beyond%20-%20%E3%80%8A%E6%9B%BE%E6%98%AF%E6%8B%A5%E6%9C%89%E3%80%8B.mp4&quot;,&quot;pic&quot;:&quot;http://p8gu1ztx5.bkt.clouddn.com/beyond.jpeg&quot;}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()&lt;/script&gt;
&lt;p&gt;致谢&lt;br&gt;   时光飞逝，岁月如梭。论文行文至此，四年本科大学时光匆匆如雨夜前的行人，突觉不舍与伤感。眺望往日，与三五同学篮球场挥舞汗水的身姿，挤在同一个实验室敲打键盘讨论学习的年少轻狂，欢声畅聊的东门小吃街对酒当歌，一幕幕恍如昨天，涌上心头。&lt;/p&gt;
    
    </summary>
    
      <category term="杂记" scheme="https://hushizhi.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="大学" scheme="https://hushizhi.github.io/tags/%E5%A4%A7%E5%AD%A6/"/>
    
      <category term="杂记" scheme="https://hushizhi.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="Beyond" scheme="https://hushizhi.github.io/tags/Beyond/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://hushizhi.github.io/uncategorized/2018/05/05/hello-world.html"/>
    <id>https://hushizhi.github.io/uncategorized/2018/05/05/hello-world.html</id>
    <published>2018-05-05T07:27:08.000Z</published>
    <updated>2018-05-05T07:27:08.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a> <h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>怎么在iPhone设置汕大邮箱</title>
    <link href="https://hushizhi.github.io/uncategorized/2018/03/25/%E5%9C%A8iPhone%E4%B8%8A%E8%AE%BE%E7%BD%AE%E6%B1%95%E5%A4%B4%E5%A4%A7%E5%AD%A6%E9%82%AE%E7%AE%B1%E7%9A%84%E6%96%B9%E6%B3%95.html"/>
    <id>https://hushizhi.github.io/uncategorized/2018/03/25/在iPhone上设置汕头大学邮箱的方法.html</id>
    <published>2018-03-25T03:51:24.000Z</published>
    <updated>2018-05-06T09:26:59.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>1.在iPhone上下载QQ邮箱应用。<br>2.进入QQ邮箱：选择“添加账户” -&gt; 选择“其他邮箱” -&gt; 输入你在汕大的“邮箱名+邮箱密码”;<br>3.此处需要填写服务器等信息，表明你的邮箱已经运行在这个服务器上，而且数据时加密的：<br>  新邮件服务器的SMTP服务器设置<br> <a id="more"></a><br>    SMTP服务器地址： smtp.partner.outlook.cn<br>    端口：587<br>    加密方法：TLS<br>4.配置完成，祝你珍惜汕大时光，好好生活，好好学习。</p><p>附：1.安卓手机配置也是一样的流程。<br>   2.配置邮箱也可以在iPhone自带邮箱应用上进行，或者在“设置”的“账户与密码”里面进行设置。<br>   3.新邮件系统不支持POP和IMAP，只支持Exchange协议。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.在iPhone上下载QQ邮箱应用。&lt;br&gt;2.进入QQ邮箱：选择“添加账户” -&amp;gt; 选择“其他邮箱” -&amp;gt; 输入你在汕大的“邮箱名+邮箱密码”;&lt;br&gt;3.此处需要填写服务器等信息，表明你的邮箱已经运行在这个服务器上，而且数据时加密的：&lt;br&gt;  新邮件服务器的SMTP服务器设置&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>sklearn.svm.SVC参数设置详解</title>
    <link href="https://hushizhi.github.io/uncategorized/2018/03/22/sklearn-svm-SVC%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E8%AF%A6%E8%A7%A3.html"/>
    <id>https://hushizhi.github.io/uncategorized/2018/03/22/sklearn-svm-SVC参数设置详解.html</id>
    <published>2018-03-22T00:52:37.000Z</published>
    <updated>2018-05-05T07:26:42.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>sklearn.svm.SVC 参数说明</p><p>这个函数也是基于libsvm实现的。参数列表如下：<br>sklearn.svm.SVC(C=1.0, kernel=’rbf’, degree=3, gamma=’auto’, coef0=0.0, shrinking=True, probability=False,tol=0.001, cache_size=200, class_weight=None, verbose=False, max_iter=-1, decision_function_shape=None,random_state=None)<br><a id="more"></a> </p><p>参数详解如下：</p><p>l  C：C-SVC的惩罚参数C?默认值是1.0</p><p>C越大，相当于惩罚松弛变量，希望松弛变量接近0，即对误分类的惩罚增大，趋向于对训练集全分对的情况，这样对训练集测试时准确率很高，但泛化能力弱。C值小，对误分类的惩罚减小，允许容错，将他们当成噪声点，泛化能力较强。</p><p>l  kernel ：核函数，默认是rbf，可以是‘linear’, ‘poly’, ‘rbf’, ‘sigmoid’, ‘precomputed’ </p><p>  　　0 – 线性：u’v</p><p> 　　 1 – 多项式：(gamma<em>u’</em>v + coef0)^degree</p><p>  　　2 – RBF函数：exp(-gamma|u-v|^2)</p><p>  　　3 –sigmoid：tanh(gamma<em>u’</em>v + coef0)</p><p>l  degree ：多项式poly函数的维度，默认是3，选择其他核函数时会被忽略。</p><p>l  gamma ： ‘rbf’,‘poly’ 和‘sigmoid’的核函数参数。默认是’auto’，则会选择1/n_features</p><p>l  coef0 ：核函数的常数项。对于‘poly’和 ‘sigmoid’有用。</p><p>l  probability ：是否采用概率估计？.默认为False</p><p>l  shrinking ：是否采用shrinking heuristic方法，默认为true</p><p>l  tol ：停止训练的误差值大小，默认为1e-3</p><p>l  cache_size ：核函数cache缓存大小，默认为200</p><p>l  class_weight ：类别的权重，字典形式传递。设置第几类的参数C为weight*C(C-SVC中的C)</p><p>l  verbose ：允许冗余输出？</p><p>l  max_iter ：最大迭代次数。-1为无限制。</p><p>l  decision_function_shape ：‘ovo’, ‘ovr’ or None, default=None3</p><p>l  random_state ：数据洗牌时的种子值，int值</p><p>主要调节的参数有：C、kernel、degree、gamma、coef0。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sklearn.svm.SVC 参数说明&lt;/p&gt;
&lt;p&gt;这个函数也是基于libsvm实现的。参数列表如下：&lt;br&gt;sklearn.svm.SVC(C=1.0, kernel=’rbf’, degree=3, gamma=’auto’, coef0=0.0, shrinking=True, probability=False,tol=0.001, cache_size=200, class_weight=None, verbose=False, max_iter=-1, decision_function_shape=None,random_state=None)&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基础篇二进制位操作</title>
    <link href="https://hushizhi.github.io/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2018/03/17/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D%E6%93%8D%E4%BD%9C.html"/>
    <id>https://hushizhi.github.io/基础知识/2018/03/17/基础篇二进制位操作.html</id>
    <published>2018-03-17T07:13:48.000Z</published>
    <updated>2018-05-05T07:26:52.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>一． 位操作基础<br>基本的位操作符有与、或、异或、取反、左移、右移这6种，它们的运算规则如下所示：</p><p>&amp;  与   两个位都为1时，结果才为1</p><p>|  或   两个位都为0时，结果才为0</p><p>^  异或  两个位相同为0，相异为1</p><p>~  取反  0变1，1变0</p><a id="more"></a> <p>&lt;&lt; 左移  各二进位全部左移若干位，高位丢弃，低位补0</p><blockquote><blockquote><p>右移  各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）</p></blockquote></blockquote><p>注意以下几点：</p><p>1．  在这6种操作符，只有~取反是单目操作符，其它5种都是双目操作符。</p><p>2．  位操作只能用于整形数据，对float和double类型进行位操作会被编译器报错。</p><p>3．  对于移位操作，比如15 = 0000 1111(二进制)，右移二位，最高位由符号位填充将得到0000 0011即3。<br>                  -15 = 1111 0001(二进制)，右移二位，最高位由符号位填充将得到1111 1100即-4。</p><p>4．  位操作符的运算优先级比较低，因为尽量使用括号来确保运算顺序。<br>比如要得到像1，3，5，9这些2^i+1的数字。写成int a = 1 &lt;&lt; i + 1;是不对的，程序会先执行i + 1，再执行左移操作。应该写成int a = (1 &lt;&lt; i) + 1;</p><p>5．  另外位操作还有一些复合操作符，如&amp;=、|=、 ^=、&lt;&lt;=、&gt;&gt;=。</p><p>二． 常用位操作小技巧<br>下面对位操作的一些常见应用作个总结，有判断奇偶、交换两数、变换符号及求绝对值。这些小技巧应用易记，应当熟练掌握。</p><p>1．判断奇偶<br>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。<br>因此可以用if ((a &amp; 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。</p><p>下面程序将输出0到100之间的所有奇数。<br>for (i = 0; i &lt; 100; ++i)<br>    if (i &amp; 1)<br>        printf(“%d “, i);<br>putchar(‘\n’);  </p><p>2．交换两数<br>一般的写法是：<br>void Swap(int &amp;a, int &amp;b)<br>{<br>    if (a != b)<br>    {<br>        int c = a;<br>        a = b;<br>        b = c;<br>    }<br>}<br>可以用位操作来实现交换两数而不用第三方变量：<br>void Swap(int &amp;a, int &amp;b)<br>{<br>    if (a != b)<br>    {<br>        a ^= b;<br>        b ^= a;<br>        a ^= b;<br>    }<br>}<br>可以这样理解：</p><p>第一步  a^=b 即a=(a^b);</p><p>第二步  b^=a 即b=b^(a^b)，由于^运算满足交换律，b^(a^b)=b^b^a。由于一个数和自己异或的结果为0并且任何数与0异或都会不变的，所以此时b被赋上了a的值。</p><p>第三步 a^=b 就是a=a^b，由于前面二步可知a=(a^b)，b=a，所以a=a^b即a=(a^b)^a。故a会被赋上b的值。</p><p>再来个实例说明下以加深印象。int a = 13, b = 6;</p><p>a的二进制为 13=8+4+1=1101(二进制)</p><p>b的二进制为 6=4+2=110(二进制)</p><p>第一步 a^=b  a = 1101 ^ 110 = 1011;</p><p>第二步 b^=a  b = 110 ^ 1011 = 1101;即b=13</p><p>第三步 a^=b  a = 1011 ^ 1101 = 110;即a=6</p><p>3．变换符号<br>变换符号就是正数变成负数，负数变成正数。</p><p>如对于-11和11，可以通过下面的变换方法将-11变成11</p><pre><code>1111 0101(二进制) –取反-&gt; 0000 1010(二进制) –加1-&gt; 0000 1011(二进制)</code></pre><p>同样可以这样的将11变成-11</p><pre><code>0000 1011(二进制) –取反-&gt; 0000 0100(二进制) –加1-&gt; 1111 0101(二进制)</code></pre><p>因此变换符号只需要取反后加1即可。完整代码如下：   </p><p>#include &lt;stdio.h&gt;<br>int SignReversal(int a)<br>{<br>    return ~a + 1;<br>}<br>int main()<br>{<br>    printf(“对整数变换符号 — by More  —\n\n”);<br>    int a = 7, b = -12345;<br>    printf(“%d  %d\n”, SignReversal(a), SignReversal(b));<br>    return 0;<br>}<br>4．求绝对值<br>位操作也可以用来求绝对值，对于负数可以通过对其取反后加1来得到正数。对-6可以这样：</p><pre><code>1111 1010(二进制) –取反-&gt;0000 0101(二进制) -加1-&gt; 0000 0110(二进制)</code></pre><p>来得到6。</p><p>因此先移位来取符号位，int i = a &gt;&gt; 31;要注意如果a为正数，i等于0，为负数，i等于-1。然后对i进行判断——如果i等于0，直接返回。否之，返回~a+1。完整代码如下：</p><p>int my_abs(int a)<br>{<br>    int i = a &gt;&gt; 31;<br>    return i == 0 ? a : (~a + 1);<br>}<br>现在再分析下。对于任何数，与0异或都会保持不变，与-1即0xFFFFFFFF异或就相当于取反。因此，a与i异或后再减i（因为i为0或-1，所以减i即是要么加0要么加1）也可以得到绝对值。所以可以对上面代码优化下：</p><p>int my_abs(int a)<br>{<br>    int i = a &gt;&gt; 31;<br>    return ((a ^ i) - i);<br>}<br>注意这种方法没用任何判断表达式，而且有些笔面试题就要求这样做，因此建议读者记住该方法（^_^讲解过后应该是比较好记了）。</p><p>注1．int类型一般占4字节，32位。因此15准确表达为</p><p>15=00000000 00000000 00000000 00001111(二进制)</p><p>-15准确表达为</p><p>-15=11111111 11111111 11111111 11110001(二进制)</p><p>为了简便起见，文章中使用15=00001111(二进制)，-15=11110001(二进制)。</p><p>应用．  二进制中1的个数</p><p>统计二进制中1的个数可以直接移位再判断，当然像《编程之美》书中用循环移位计数或先打一个表再计算都可以。本文详细讲解一种高效的方法。以34520为例，可以通过下面四步来计算其二进制中1的个数二进制中1的个数。</p><p>第一步：每2位为一组，组内高低位相加</p><pre><code>10 00 01 10  11 01 10 00</code></pre><p>  –&gt;01 00 01 01  10 01 01 00</p><p>第二步：每4位为一组，组内高低位相加</p><pre><code>0100 0101 1001 0100</code></pre><p>  –&gt;0001 0010 0011 0001</p><p>第三步：每8位为一组，组内高低位相加</p><pre><code>00010010 00110001</code></pre><p>  –&gt;00000011 00000100</p><p>第四步：每16位为一组，组内高低位相加</p><pre><code>00000011 00000100</code></pre><p>  –&gt;00000000 00000111</p><p>这样最后得到的00000000 00000111即7即34520二进制中1的个数。类似上文中对二进制逆序的做法不难实现第一步的代码：</p><pre><code>x = ((x &amp; 0xAAAA) &gt;&gt; 1) + (x &amp; 0x5555);</code></pre><p>好的，有了第一步，后面几步就请读者完成下吧，先动动笔再看下面的完整代码：</p><p>#include &lt;stdio.h&gt;<br>template <class t><br>void PrintfBinary(T a)<br>{<br>    int i;<br>    for (i = sizeof(a) * 8 - 1; i &gt;= 0; –i)<br>    {<br>        if ((a &gt;&gt; i) &amp; 1)<br>            putchar(‘1’);<br>        else<br>            putchar(‘0’);<br>        if (i == 8)<br>            putchar(‘ ‘);<br>    }<br>    putchar(‘\n’);<br>}<br>int main()<br>{<br>    printf(“二进制中1的个数 — by MoreWindows( <a href="http://blog.csdn.net/MoreWindows" target="_blank" rel="noopener">http://blog.csdn.net/MoreWindows</a> )  —\n\n”);  </class></p><pre><code>unsigned short a = 34520;  printf(&quot;原数    %6d的二进制为:  &quot;, a);  PrintfBinary(a);  a = ((a &amp; 0xAAAA) &gt;&gt; 1) + (a &amp; 0x5555);  a = ((a &amp; 0xCCCC) &gt;&gt; 2) + (a &amp; 0x3333);  a = ((a &amp; 0xF0F0) &gt;&gt; 4) + (a &amp; 0x0F0F);  a = ((a &amp; 0xFF00) &gt;&gt; 8) + (a &amp; 0x00FF);     printf(&quot;计算结果%6d的二进制为:  &quot;, a);     PrintfBinary(a);  return 0;  </code></pre><p>}<br>运行结果如下：</p><p>可以发现巧妙运用分组处理确实是解决很多二进制问题的灵丹妙药。</p><p>转载自：<a href="http://blog.csdn.net/morewindows/article/details/7354571" target="_blank" rel="noopener">http://blog.csdn.net/morewindows/article/details/7354571</a><br>感谢原作者</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一． 位操作基础&lt;br&gt;基本的位操作符有与、或、异或、取反、左移、右移这6种，它们的运算规则如下所示：&lt;/p&gt;
&lt;p&gt;&amp;amp;  与   两个位都为1时，结果才为1&lt;/p&gt;
&lt;p&gt;|  或   两个位都为0时，结果才为0&lt;/p&gt;
&lt;p&gt;^  异或  两个位相同为0，相异为1&lt;/p&gt;
&lt;p&gt;~  取反  0变1，1变0&lt;/p&gt;
    
    </summary>
    
      <category term="基础知识" scheme="https://hushizhi.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="位操作" scheme="https://hushizhi.github.io/tags/%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>机器学习之支持向量机</title>
    <link href="https://hushizhi.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/2018/01/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA.html"/>
    <id>https://hushizhi.github.io/机器学习/2018/01/20/机器学习之支持向量机.html</id>
    <published>2018-01-20T02:22:24.000Z</published>
    <updated>2018-05-05T07:27:19.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>机器学习实战之SVM</p><p>　　支持向量机这部分确实很多，想要真正的去理解它，不仅仅知道理论，还要进行相关的代码编写和测试，二者想和结合，才能更好的帮助我们理解SVM这一非常优秀的分类算法</p><p>　　支持向量机是一种二类分类算法，假设一个平面可以将所有的样本分为两类，位于正侧的样本为一类，值为+1，而位于负一侧的样本为另外一类，值为-1。</p><p>　　我们说分类，不仅仅是将不同的类别样本分隔开，还要以比较大的置信度来分隔这些样本，这样才能使绝大部分样本被分开。比如，我们想通过一个平面将两个类别的样本分开，如果这些样本是线性可分（或者近视线性可分），那么这样的平面有很多，但是如果我们加上要以最大的置信度来将这些样本分开，那么这样的平面只有一条。那么怎么才能找到这样的平面呢？这里不得不提到几个概念<br><a id="more"></a> </p><p>1 几何间隔</p><p>　　几何间隔的概念，简单理解就是样本点到分隔平面的距离</p><p>2 间隔最大化</p><p>　　想要间隔最大化，我们必须找到距离分隔平面最近的点，并且使得距离平面最近的点尽可能的距离平面最远，这样，每一个样本就都能够以比较大的置信度被分隔开</p><p>算法的分类预测能力也就越好</p><p>　　显然，SVM算法的关键所在，就是找到使得间隔最大化的分隔超平面（如果特征是高维度的情况，我们称这样的平面为超平面）</p><p>　　这里关于SVM学习，推荐两本书：统计学习方法（李航）和机器学习实战，二者结合，可以帮助我们理解svm算法</p><p>2 支持向量机</p><p>　　支持向量机的推导，可以看李航的统计与学习方法书，写的浅显易懂。</p><p>　　这两位博主都重点讲解了SVM的推导过程。这里我就本着站在巨人的肩膀上的思想，不再赘述，我的侧重点在于实际的代码编写上，比较理论总归要回到实践上，这也是每个算法的归宿所在。</p><p>　　好了，下面我就简要写出简要介绍一下，线性支持向量机，近似线性支持向量机以及非线性支持向量机（核函数）</p><p>1 线性支持向量机</p><p>　　求解线性支持向量机的过程是凸二次规划问题，所谓凸二次规划问题，就是目标函数是凸的二次可微函数，约束函数为仿射函数（满足f(x)=a<em>x+b,a,x均为n为向量）。而我们说求解凸二次规划问题可以利用对偶算法–即引入拉格朗日算子，利用拉格朗日对偶性将原始问题的最优解问题转化为拉格朗日对偶问题，这样就将求w</em>，b的原始问题的极小问题转化为求alpha<em>（alpha&gt;=0）的对偶问题的极大问题，即求出alpha</em>，在通过KKT条件求出对应的参数w*，b，从而找到这样的间隔最大化超平面，进而利用该平面完成样本分类</p><p>2 近似线性支持向量机</p><p>　　当数据集并不是严格线性可分时，即满足绝不部分样本点是线性可分，存在极少部分异常点；这里也就是说存在部分样本不能满足约束条件，此时我们可以引入松弛因子，这样这些样本点到超平面的函数距离加上松弛因子，就能保证被超平面分隔开来；当然，添加了松弛因子sigma，我们也会添加对应的代价项，使得alpha满足0=&lt;alpha&lt;=C</p><p>3 非线性支持向量机</p><p>　　显然，当数据集不是线性可分的，即我们不能通过前面的线性模型来对数据集进行分类。此时，我们必须想办法将这些样本特征符合线性模型，才能通过线性模型对这些样本进行分类。这就要用到核函数，核函数的功能就是将低维的特征空间映射到高维的特征空间，而在高维的特征空间中，这些样本进过转化后，变成了线性可分的情况，这样，在高维空间中，我们就能够利用线性模型来解决数据集分类问题</p><p>   好了，我们就只讲这么写大致的概念，如果想要透彻理解SVM建议还是要看看上面的书和博客文章，篇幅有限，我这里的中心在于凸二次规划的优化算法–SMO(序列最小最优化算法)</p><p>3 SMO算法</p><p>　　SMO是一种用于训练SVM的强大算法，它将大的优化问题分解为多个小的优化问题来进行求解。而这些小优化问题往往很容易求解，并且对它们进行顺序求解和对整体求解结果是一致的。在结果一致的情况下，显然SMO算法的求解时间要短很多，这样当数据集容量很大时，SMO就是一致十分高效的算法</p><p>　　SMO算法的目标是找到一系列alpha和b，而求出这些alpha，我们就能求出权重w，这样就能得到分隔超平面，从而完成分类任务</p><p>　　SMO算法的工作原理是：每次循环中选择两个alpha进行优化处理。一旦找到一对合适的alpha，那么就增大其中一个而减少另外一个。这里的”合适”,意味着在选择alpha对时必须满足一定的条件，条件之一是这两个alpha不满足最优化问题的kkt条件，另外一个条件是这两个alpha还没有进行区间化处理</p><p>　　对于SMO算法编写，我们采用由简单到复杂的方法，层层递进，完成最终的SMO算法实现，最后通过实际的用例对SVM模型进行训练，并验证准确性</p><p>1 简化版SMO算法</p><p>　　简化版SMO算法，省略了确定要优化的最佳alpha对的步骤，而是首先在数据集上进行遍历每一个alpha，再在剩余的数据集中找到另外一个alpha，构成要优化的alpha对，同时对其进行优化，这里的同时是要确保公式：Σαi*label(i)=0。所以改变一个alpha显然会导致等式失效，所以这里需要同时改变两个alpha。接下来看实际的代码：</p><p>　　简易版SMO算法的辅助函数：</p><p>复制代码</p><p>#SMO算法相关辅助中的辅助函数</p><p>#1 解析文本数据函数，提取每个样本的特征组成向量，添加到数据矩阵</p><p>#添加样本标签到标签向量<br>def loadDataSet(filename):<br>    dataMat=[];labelMat=[]<br>    fr=open(filename)<br>    for line in fr.readlines():<br>        lineArr=line.strip().split(‘\t’)<br>        dataMat.append([float(lineArr[0]),float(lineArr[1])])<br>        labelMat.append((float()lineArr[2]))<br>    return dataMat,labelMat</p><p>#2 在样本集中采取随机选择的方法选取第二个不等于第一个alphai的</p><p>#优化向量alphaj<br>def selectJrand(i,m):<br>    j=i<br>    while(j==i):<br>        j=int(random.uniform(0,m))<br>    return j</p><p>#3 约束范围L&lt;=alphaj&lt;=H内的更新后的alphaj值<br>def clipAlpha(aj,H,L):<br>    if aj&gt;H:<br>        aj=H<br>    if L&gt;aj：<br>        aj=L<br>    return aj<br>复制代码<br>上面是简易版SMO算法需要用到的一些功能，我们将其包装成函数，需要时调用即可，接下来看算法的伪代码：</p><p>复制代码</p><p>#SMO算法的伪代码</p><p>#创建一个alpha向量并将其初始化为0向量</p><p>#当迭代次数小于最大迭代次数时(w外循环)</p><pre><code>#对数据集中每个数据向量(内循环):#如果该数据向量可以被优化：    #随机选择另外一个数据向量    #同时优化这两个向量    #如果两个向量都不能被优化，退出内循环</code></pre><p>#如果所有向量都没有被优化，增加迭代次数，继续下一次循环<br>复制代码<br>实际代码如下：</p><p>复制代码</p><p>#@dataMat    ：数据列表</p><p>#@classLabels：标签列表</p><p>#@C          ：权衡因子（增加松弛因子而在目标优化函数中引入了惩罚项）</p><p>#@toler      ：容错率</p><p>#@maxIter    ：最大迭代次数<br>def smoSimple(dataMat,classLabels,C,toler,maxIter):</p><pre><code>#将列表形式转为矩阵或向量形式dataMatrix=mat(dataMatIn);labelMat=mat(classLabels).transpose()#初始化b=0，获取矩阵行列b=0;m,n=shape(dataMatrix)#新建一个m行1列的向量alphas=mat(zeros((m,1)))#迭代次数为0iter=0while(iter&lt;maxIter):    #改变的alpha对数    alphaPairsChanged=0    #遍历样本集中样本    for i in range(m):        #计算支持向量机算法的预测值        fXi=float(multiply(alphas,labelMat).T*\        (dataMatrix*dataMatrix[i,:].T))+b        #计算预测值与实际值的误差        Ei=fXi-float(labelMat[i])        #如果不满足KKT条件，即labelMat[i]*fXi&lt;1(labelMat[i]*fXi-1&lt;-toler)        #and alpha&lt;C 或者labelMat[i]*fXi&gt;1(labelMat[i]*fXi-1&gt;toler)and alpha&gt;0        if((labelMat[i]*Ei&lt;-toler)and(alpha&lt;C))or\        ((labelMat[i]*Ei&gt;toler)and(alpha[i]&gt;0))):            #随机选择第二个变量alphaj            j=selectJrand(i,m)            #计算第二个变量对应数据的预测值            fXj=float(multiply(alphas,labelMat).T*\                (dataMatrix*dataMatrix[j,:]).T)+b            #计算与测试与实际值的差值            Ej=fXj-float(label[j])            #记录alphai和alphaj的原始值，便于后续的比较            alphaIold=alphas[i].copy()            alphaJold=alphas[j].copy()            #如何两个alpha对应样本的标签不相同            if(labelMat[i]!=labelMat[j]):                #求出相应的上下边界                L=max(0,alphas[j]-alphas[i])                H=min(C,C+alphas[j]-alphas[i])            else:                L=max(0,alphas[j]+alphas[i]-C)                H=min(C,alphas[j]+alphas[i])            if L==H:print(&quot;L==H);continue            #根据公式计算未经剪辑的alphaj            #------------------------------------------            eta=2.0*dataMatrix[i,:]*dataMatrix[j,:].T-\                dataMatrix[i,:]*dataMatrix[i,:].T-\                dataMatrix[j,:]*dataMatrix[j,:].T            #如果eta&gt;=0,跳出本次循环            if eta&gt;=0:print(&quot;eta&gt;=0&quot;):continue                alphas[j]-=labelMat[j]*(Ei-Ej)/eta                alphas[j]=clipAlpha(alphas[j],H,L)            #------------------------------------------                #如果改变后的alphaj值变化不大，跳出本次循环                if(abs(alphas[j]-alphaJold)&lt;0.00001):print(&quot;j not moving\            enough&quot;);continue            #否则，计算相应的alphai值            alphas[i]+=labelMat[j]*labelMat[i]*(alphaJold-alphas[j])            #再分别计算两个alpha情况下对于的b值            b1=b-Ei-labelMat[i]*(alphas[i]-alphaIold)*\                dataMatrix[i,:]*dataMat[i,:].T-\                labelMat[j]*(alphas[j]-alphaJold)*\                dataMatrix[i,:]*dataMatrix[j,:].T            b2=b-Ej-labelMat[i]*(alphas[i]-alphaIold)*\                dataMatrix[i,:]*dataMatrix[j,:].T-\                labelMat[j]*(alphas[j]-alphaJold)*\                dataMatrix[j,:]*dataMatrix[j,:].T            #如果0&lt;alphai&lt;C,那么b=b1            if(0&lt;alphas[i]) and (C&gt;alphas[i]):b=b1            #否则如果0&lt;alphai&lt;C,那么b=b1            elif (0&lt;alphas[j]) and (C&gt;alphas[j]):b=b2            #否则，alphai，alphaj=0或C            else:b=(b1+b2)/2.0            #如果走到此步，表面改变了一对alpha值            alphaPairsChanged+=1            print(&quot;iter: &amp;d i:%d,paird changed %d&quot;,%(iter,i,alphaPairsChanged))    #最后判断是否有改变的alpha对，没有就进行下一次迭代    if(alphaPairsChanged==0):iter+=1    #否则，迭代次数置0，继续循环    else:iter=0    print(&quot;iteration number: %d&quot; %iter)#返回最后的b值和alpha向量return b,alphas</code></pre><p>复制代码<br>     上面的代码量看起来很多，但事实上只要理解了SVM算法的理论知识，就很容易理解，其只不过是将理论转化为机器可以运行的语言而已。</p><p>　  上面代码在一台性能一般的笔记本上对100个样本的数据集上运行，收敛时间14.5秒，取得了令人满意的分类效果</p><pre><code>当然，上面的代码通过对整个数据集进行两次遍历的方法来寻找alpha对的方法，显然存在一定的不足，如果数据集规模较小的情况下，或许还可以满足要求。但是对于大规模的数据集而言，上面的代码显然收敛速度非常慢，所以，接下来我们在此基础上对选取合适的alpha对方法进行改进，采用启发式的方法来选取合适的alpha对，从而提升运算效率。</code></pre><p>2 启发式选取alpha变量的SMO算法</p><p>　　启发式的SMO算法一个外循环来选择第一个alpha值，并且其选择过程会在下面两种方法之间进行交替：</p><p>（1）在所有数据集上进行单遍扫描</p><p>（2）另一种方法是在间隔边界上样本点进行单遍扫描，所谓间隔边界上的点即为支持向量点。</p><pre><code>显然，对于整个数据集遍历比较容易，而对于那些处于间隔边界上的点，我们还需要事先将这些点对应的alpha值找出来，存放在一个列表中，然后对列表进行遍历；此外，在选择第一个alpha值后，算法会通过一个内循环来选择第二个值，在优化的过程中依据alpha的更新公式αnew,unc=aold+label*(Ei-Ej)/η，(η=dataMat[i,:]*dataMat[i,:].T+dataMat[j,:]*dataMat[j,:].T-2*dataMat[i,:]*dataMat[j,:].T),可知alpha值的变化程度更Ei-Ej的差值成正比，所以，为了使alpha有足够大的变化，选择使Ei-Ej最大的alpha值作为另外一个alpha。所以，我们还可以建立一个全局的缓存用于保存误差值，便于我们选择合适的alpha值</code></pre><p>　　下面是创建的一个数据结构类，便于我们存取算法中需要用到的重要数据：</p><p>复制代码</p><p>#启发式SMO算法的支持函数</p><p>#新建一个类的收据结构，保存当前重要的值<br>class optStruct:<br>    def <strong>init</strong>(self,dataMatIn,classLabels,C,toler):<br>        self.X=dataMatIn<br>        self.labelMat=classLabels<br>        self.C=C<br>        self.tol=toler<br>        self.m=shape(dataMatIn)[0]<br>        self.alphas=mat(zeros((self.m,1)))<br>        self.b=0<br>        self.eCache=mat(zeros((self.m,2)))</p><p>#格式化计算误差的函数，方便多次调用<br>def calcEk(oS,k):<br>    fXk=float(multiply(oS.alphas,oS.labelMat).T<em>\<br>        (oS.X</em>oS.X[k,:].T))+oS.b<br>    Ek=fXk-float(oS.labelMat[k])<br>    return Ek</p><p>#修改选择第二个变量alphaj的方法<br>def selectJ(i,oS,Ei):<br>    maxK=-1;maxDeltaE=-;Ej=0</p><pre><code>#将误差矩阵每一行第一列置1，以此确定出误差不为0#的样本oS.eCache[i]=[1,Ei]#获取缓存中Ei不为0的样本对应的alpha列表validEcacheList=nonzero(oS.Cache[:,0].A)[0]#在误差不为0的列表中找出使abs(Ei-Ej)最大的alphajif(len(validEcacheList)&gt;0):    for k in validEcacheList:        if k ==i:continue        Ek=calcEk(oS,k)        deltaE=abs(Ei-Ek)        if(deltaE&gt;maxDeltaE):            maxK=k;maxDeltaE=deltaE;Ej=Ek    return maxK,Ejelse:#否则，就从样本集中随机选取alphaj    j=selectJrand(i,oS.m)    Ej=calcEk(oS,j)return j,Ej</code></pre><p>#更新误差矩阵<br>def updateEk(oS,k):<br>    Ek=calcEk(oS,k)<br>    oS.eCache[k]=[1,Ek]<br>复制代码<br>　　好了，有了这些辅助性的函数，我们就可以很容易的实现启发式的SMO算法的具体代码：</p><p>复制代码</p><p>#SMO外循环代码<br>def smoP(dataMatIn,classLabels,C,toler,maxIter,kTup=(‘lin’,0))：</p><pre><code>#保存关键数据oS=optStruct(mat(dataMatIn),mat(classLabels).transpose(),C,toler)iter=0enrireSet=True;alphaPairsChanged=0#选取第一个变量alpha的三种情况，从间隔边界上选取或者整个数据集while(iter&lt;maxIter)and((alphaPairsChanged&gt;0)or(entireSet)):    alphaPairsChanged=0    #没有alpha更新对    if entireSet:        for i in range(oS.m):            alphaPairsChanged+=innerL(i,oS)        print(&quot;fullSet,iter: %d i:%d,pairs changed %d&quot;,%\            (iter,i,alphaPairsChanged))    else:        #统计alphas向量中满足0&lt;alpha&lt;C的alpha列表        nonBoundIs=nonzero((oS.alphas.A)&gt;0)*(oS.alphas.A&lt;C))[0]        for i in nonBoundIs:            alphaPairsChanged+=innerL(i,oS)            print(&quot;non-bound,iter: %d i:%d,pairs changed %d&quot;,%\            (iter,i,alphaPairsChanged))        iter+=1    if entireSet:entireSet=False    #如果本次循环没有改变的alpha对，将entireSet置为true，    #下个循环仍遍历数据集    elif (alphaPairsChanged==0):entireSet=True    print(&quot;iteration number: %d&quot;,%iter)return oS.b,oS.alphas</code></pre><p>#内循环寻找alphaj<br>def innerL(i,oS):</p><pre><code>#计算误差Ei=calcEk(oS,i)#违背kkt条件if(((oS.labelMat[i]*Ei&lt;-oS.tol)and(oS.alphas[i]&lt;oS.C))or\        ((oS.labelMat[i]*Ei&gt;oS.tol)and(oS.alphas[i]&gt;0))):    j,Ej=selectJ(i,oS,Ei)    alphaIold=alphas[i].copy();alphaJold=alphas[j].copy()    #计算上下界    if(oS.labelMat[i]!=oS.labelMat[j]):        L=max(0,oS.alphas[j]-oS.alphas[i])        H=min(oS.C,oS.C+oS.alphas[j]-oS.alphas[i])    else:        L=max(0,oS.alphas[j]+oS.alphas[i]-oS.C)        H=min(oS.C,oS.alphas[j]+oS.alphas[i])    if L==H:print(&quot;L==H&quot;);return 0    #计算两个alpha值    eta=2.0*oS.X[i,:]*oS.X[j,:].T-oS.X[i,:]*oS.X[i,:].T-\        oS.X[j,:]*oS.X[j,:].T    if eta&gt;=0:print(&quot;eta&gt;=0&quot;);return 0    oS.alphas[j]-=oS.labelMat[j]*(Ei-Ej)/eta    oS.alphas[j]=clipAlpha(oS.alphas[j],H,L)    updateEk(oS,j)    if(abs(oS.alphas[j]-alphaJold)&lt;0.00001):        print(&quot;j not moving enough&quot;);return 0    oS.alphas[i]+=oS.labelMat[j]*oS.labelMat[i]*\        (alphaJold-oS.alphas[j])    updateEk(oS,i)    #在这两个alpha值情况下，计算对应的b值    #注，非线性可分情况，将所有内积项替换为核函数K[i,j]    b1=oS.b-Ei-oS.labelMat[i]*(oS.alphas[i]-alphaIold)*\                oS.X[i,:]*oS.X[i,:].T-\                oS.labelMat[j]*(oS.alphas[j]-alphaJold)*\                oS.X[i,:]*oS.X[j,:].T    b2=oS.b-Ej-oS.labelMat[i]*(oS.alphas[i]-alphaIold)*\                oS.X[i,:]*oS.X[j,:].T-\                oS.labelMat[j]*(oS.alphas[j]-alphaJold)*\                oS.X[j,:]*oS.X[j,:].T    if(0&lt;oS.alphas[i])and (oS.C&gt;oS.alphas[i]):oS.b=b1    elif(0&lt;oS.alphas[j])and (oS.C&gt;oS.alphas[j]):oS.b=b2    else:oS.b=(b1+b2)/2.0    #如果有alpha对更新    return 1        #否则返回0        else return 0</code></pre><p>复制代码<br>     显然，上面的SMO完整代码是分为内外两个循环函数来编写的，采取这样的结构可以更方便我们去理解选取两个alpha的过程；既然，我们已经计算出了alpha值和b值，那么显然我们可以利用公式w<em>=Σαi</em>label[i]<em>dataMat[i,:]计算出相应的权值参数，然后就可以得到间隔超平面的公式w</em>x+b<em>来完成样本的分类了，由于SVM算法是一种二类分类算法，正值为1，负值为-1，即分类的决策函数为跳跃函数sign（w</em>x+b*）</p><p>然后，我们可以编写一小段测试代码，来利用SMO算法得到的alpha值和b值，计算分类决策函数，从而实现具体的预测分类了</p><p>复制代码</p><p>#求出了alpha值和对应的b值，就可以求出对应的w值，以及分类函数值<br>def predict(alphas,dataArr,classLabels):<br>    X=mat(dataArr);labelMat=mat(classLabels)<br>    m,n=shape(X)<br>    w=zeros((n,1))<br>    for i in range(m):<br>        w+=multiply(alphas[i]<em>labelMat[i],X[i,:].T)<br>    result=dataArr[0]</em>mat(ws)+b<br>    return sign(result)</p><p>复制代码<br>      看一下分类效果：</p><p>3 核函数</p><p>　　核函数的目的主要是为了解决非线性分类问题，通过核技巧将低维的非线性特征转化为高维的线性特征，从而可以通过线性模型来解决非线性的分类问题。</p><p>如下图，当数据集不是线性可分时，即数据集分布是下面的圆形该怎么办呢？</p><p>　　显然，此时数据集线性不可分，我们无法用一个超平面来将两种样本分隔开；那么我们就希望将这些数据进行转化，转化之后的数据就能够通过一个线性超平面将不同类别的样本分开，这就需要核函数，核函数的目的主要是为了解决非线性分类问题，通过核技巧将低维的非线性特征转化为高维的线性特征，从而可以通过线性模型来解决非线性的分类问题。</p><p>　　而径向基核函数，是SVM中常用的一个核函数。径向基核函数是一个采用向量作为自变量的函数，能够基于向量距离运算输出一个标量。径向基核函数的高斯版本公式为：</p><p>　　k(x，y)=exp(-||x-y||2/2σ2),其中，σ为到达率，决定了函数值跌落至0的速度</p><p>　　下面通过代码编写高斯核函数：</p><p>复制代码</p><p>#径向基核函数是svm常用的核函数</p><p>#核转换函数<br>def kernelTrans(X,A,kTup):<br>    m,n=shape(X)<br>    K=mat(zeros((m,1)))</p><pre><code>#如果核函数类型为&apos;lin&apos;if kTup[0]==&apos;lin&apos;:K=X*A.T#如果核函数类型为&apos;rbf&apos;:径向基核函数#将每个样本向量利用核函数转为高维空间elif kTup[0]==&apos;rbf&apos;    for j in range(m):        deltaRow=X[j,:]-A        K[j]=deltaRow*deltaRow.T    K=exp(K/(-1*kTup[1]**2))else：raise NameError(&apos;Houston we Have a Problem -- \That Kernel is not recognised&apos;)return K</code></pre><p>#对核函数处理的样本特征，存入到optStruct中<br>class optStruct：<br>    def <strong>init</strong>(self,dataMatIn,classLabels,C,toler,kTup):<br>        self.X=dataMatIn<br>        self.labelMat=classLabels<br>        self.C=C<br>        self.tol=toler<br>        self.m=shape(dataMatIn)[0]<br>        self.alphas=mat(zeros((self.m,1)))<br>        self.b=0<br>        self.eCache=mat(zeros((self.m,2)))<br>        self.K=mat(zeros((self.m,self.m)))<br>        for i in range(self.m):<br>            self.K[:,i]=kernelTrans(self.X,self.X[i,:],kTup)<br>复制代码<br>需要说明的是，这里引入了一个变量kTup,kTup是一个包含核信息的元组，它提供了选取的核函数的类型，比如线性’lin’或者径向基核函数’rbf’;以及用户提供的到达率σ</p><p>　　有了高斯核函数之后，我们只要将上面的SMO算法中所有的内积项替换为核函数即可，比如讲dataMat[i,:]*dataMat[j,:].T替换为k[i,j]即可，替换效果如下：</p><p>复制代码<br>def innerL(i,oS):</p><pre><code>#计算误差Ei=calcEk(oS,i)#违背kkt条件if(((oS.labelMat[i]*Ei&lt;-oS.tol)and(oS.alphas[i]&lt;oS.C))or\        ((oS.labelMat[i]*Ei&gt;oS.tol)and(oS.alphas[i]&gt;0))):    j,Ej=selectJ(i,oS,Ei)    alphaIold=alphas[i].copy();alphaJold=alphas[j].copy()    #计算上下界    if(oS.labelMat[i]!=oS.labelMat[j]):        L=max(0,oS.alphas[j]-oS.alphas[i])        H=min(oS.C,oS.C+oS.alphas[j]-oS.alphas[i])    else:        L=max(0,oS.alphas[j]+oS.alphas[i]-oS.C)        H=min(oS.C,oS.alphas[j]+oS.alphas[i])    if L==H:print(&quot;L==H&quot;);return 0    #计算两个alpha值    eta=2.0*oS.K[i,j]-oS.K[i,i]-oS.K[j,j]    if eta&gt;=0:print(&quot;eta&gt;=0&quot;);return 0    oS.alphas[j]-=oS.labelMat[j]*(Ei-Ej)/eta    oS.alphas[j]=clipAlpha(oS.alphas[j],H,L)    updateEk(oS,j)    if(abs(oS.alphas[j]-alphaJold)&lt;0.00001):        print(&quot;j not moving enough&quot;);return 0    oS.alphas[i]+=oS.labelMat[j]*oS.labelMat[i]*\        (alphaJold-oS.alphas[j])    updateEk(oS,i)    #在这两个alpha值情况下，计算对应的b值    #注，非线性可分情况，将所有内积项替换为核函数K[i,j]    b1=oS.b-Ei-oS.labelMat[i]*(oS.alphas[i]-alphaIold)*\                oS.K[i,i]-\                oS.labelMat[j]*(oS.alphas[j]-alphaJold)*\                oS.k[i,j]    b2=oS.b-Ej-oS.labelMat[i]*(oS.alphas[i]-alphaIold)*\                oS.k[i,j]-\                oS.labelMat[j]*(oS.alphas[j]-alphaJold)*\                oS.k[i,j]    if(0&lt;oS.alphas[i])and (oS.C&gt;oS.alphas[i]):oS.b=b1    elif(0&lt;oS.alphas[j])and (oS.C&gt;oS.alphas[j]):oS.b=b2    else:oS.b=(b1+b2)/2.0    #如果有alpha对更新    return 1        #否则返回0        else return 0</code></pre><p>复制代码<br>　有了核函数，我们就能对非线性的数据集进行分类预测了，接下来就是编写代码利用核函数进行测试，需要说明的是，在优化的过程中，我们仅仅需要找到支持向量和其对应的alpha值，而对于其他的样本值可以不用管，甚至可以舍弃，因为这些样本将不会对分类预测函数造成任何影响。这也就是SVM相比KNN算法的优秀的地方所在</p><p>复制代码</p><p>#测试核函数</p><p>#用户指定到达率<br>def testRbf(k1=1.3):</p><pre><code>#第一个测试集dataArr,labelArr=loadDataSet(&apos;testSetRBF.txt&apos;)b,alphas=smoP(dataArr,labelArr,200,0.0001,10000,(&apos;rbf&apos;,k1))dataMat=mat(dataArr);labelMat=mat(labelArr).transpose()svInd=nonzero(alphas.A&gt;0)[0]sVs=dataMat[svInd]labelSV=labelMat[svInd]print(&quot;there are %d Support Vectors&quot;,%shape(sVs)[0])m,n=shape(dataMat)errorCount=0for i in range(m):    kernelEval=kernelTrans(sVs,dataMat[i,:],(&apos;rbf&apos;,k1))    predict=kernelEval.T*multiply(labelSV,alphas[svInd])+b    if sign(predict)!=sign(labelArr[i]):errorCount+=1print(&quot;the training error rate is: %f&quot;,%(float(errorCount)/m))#第二个测试集dataArr,labelArr=loadDataSet(&apos;testSetRBF2.txt&apos;)dataMat=mat(dataArr);labelMat=mat(labelArr).transpose()errorCount=0m,n=shape(dataMat)for i in range(m):    kernelEval=kernelTrans(sVs,dataMat[i,:],(&apos;rbf&apos;,k1))    predict=kernelEval.T*multiply(labelSV,alphas[svInd])+b    if sign(predict)!=sign(labelArr[i]):errorCount+=1print(&quot;the training error rate is: %f&quot;,%(float(errorCount)/m))</code></pre><p>复制代码<br>     当用户输入σ=1.3时的实验结果为：</p><pre><code> 当σ=0.1时实验结果为：通过输入不同的σ值（当然，迭代次数也会有一定的影响，我们只讨论σ值），我们发现测试错误率，训练误差率，支持向量个数都会发生变化，在一定的范围内，支持向量数目的下降，会使得训练错误率和测试错误率都下降，但是当抵达某处的最优值时，再次通过增大σ值的方法减少支持向量，此时训练错误率下降，而测试误差上升</code></pre><p>　　简言之，对于固定的数据集，支持向量的数目存在一个最优值，如果支持向量太少，会得到一个很差的决策边界；而支持向量太多，也相当于利用整个数据集进行分类，就类似于KNN算法，显然运算速度不高。</p><p>三，SVM实例：手写识别问题</p><p>　　相较于第二张的KNN算法，尽管KNN也能取得不错的效果；但是从节省内存的角度出发，显然SVM算法更胜一筹，因为其不需要保存真个数据集，而只需要其作用的支持向量点，而取得不错的分类效果。</p><p>复制代码</p><p>#实例：手写识别问题</p><p>#支持向量机由于只需要保存支持向量，所以相对于KNN保存整个数据集占用更少内存</p><p>#且取得可比的效果</p><p>#基于svm的手写数字识别<br>def loadImages(dirName):<br>    from os import listdir<br>    hwLabels=[]<br>    trainingFileList=listdir(dirName)<br>    m=len(trainingFileList)<br>    trainingMat=zeros((m,1024))<br>    for i in range(m):<br>        fileNameStr=trainingFileList[i]<br>        fileStr=fileNameStr.split(‘.’)[0]<br>        classNumStr=int(fileStr.split(‘_’)[0])<br>        if classNumStr==9:hwLabels.append(-1)<br>        else:hwLabels.append(1)<br>        trainingMat[i,:]=img2vector(‘%s/%s’,%(dirName,fileNameStr))<br>    return hwLabels,trainingMat</p><p>#将图像转为向量<br>def img2vector(fileaddir):<br>    featVec=zeros((1,1024))<br>    fr=open(filename)<br>    for i in range(32):<br>        lineStr=fr.readline()<br>        for j in range(32):<br>            featVec[0,32*i+j]=int(lineStr[j])<br>    return featVec</p><p>#利用svm测试数字<br>def testDigits(kTup=(‘rbf’,10)):</p><pre><code>#训练集dataArr,labelArr=loadDataSet(&apos;trainingDigits&apos;)b,alphas=smoP(dataArr,labelArr,200,0.0001,10000,kTup)dataMat=mat(dataArr);labelMat=mat(labelArr).transpose()svInd=nonzero(alphas.A&gt;0)[0]sVs=dataMat[svInd]labelSV=labelMat[svInd]print(&quot;there are %d Support Vectors&quot;,%shape(sVs)[0])m,n=shape(dataMat)errorCount=0for i in range(m):    kernelEval=kernelTrans(sVs,dataMat[i,:],kTup)    predict=kernelEval.T*multiply(labelSV,alphas[svInd])+b    if sign(predict)!=sign(labelArr[i]):errorCount+=1print(&quot;the training error rate is: %f&quot;,%(float(errorCount)/m))#测试集dataArr,labelArr=loadDataSet(&apos;testDigits.txt&apos;)dataMat=mat(dataArr);labelMat=mat(labelArr).transpose()errorCount=0m,n=shape(dataMat)for i in range(m):    kernelEval=kernelTrans(sVs,dataMat[i,:],(&apos;rbf&apos;,k1))    predict=kernelEval.T*multiply(labelSV,alphas[svInd])+b    if sign(predict)!=sign(labelArr[i]):errorCount+=1print(&quot;the training error rate is: %f&quot;,%(float(errorCount)/m))</code></pre><p>复制代码<br>下面来看一下，在kTup=(‘rbf’,20)情况下的测试误差率和支持向量个数情况</p><p>并且通过尝试不同的σ值，以及尝试了线性核函数，可以得到关于不同σ值的书写数字识别性能：</p><p>内核模式，设置    训练错误率(%)    测试错误率(%)    支持向量数<br>rbf,0.1    0    52    402<br>rbf,5    0    3.2    402<br>rbf,10    0    0.5    99<br>rbf,50    0.2    2.2    41<br>rbf,100    4.5    4.3    26<br>Linear    2.7    2.2    38<br>      由上图可以看出，σ值在取10时取得了最好的分类效果，这也印证了我们上面的叙述。即对于固定的数据集，存在最优的支持向量个数，使得分类错误率最低。支持向量的个数会随着σ值的增大而逐渐减少，但是分类错误率确实一个先降低后升高的过程。即最小的分类错误率并不意味着最少的支持向量个数。</p><p>4 总结</p><p>　　支持向量机是一种通过求解凸二次规划问题来解决分类问题的算法，具有较低的泛化错误率。而SMO算法可以通过每次只优化两个alpha值来加快SVM的训练速度。</p><p>　　核技巧是将数据由低维空间映射到高维空间，可以将一个低维空间中的非线性问题转换为高维空间下的线性问题来求解。而径向基核函数是一个常用的度量两个向量距离的核函数。</p><p>　　最后，支持向量机的优缺点：</p><p>　　　优点：泛化错误率低，计算开销不大</p><p>　　　缺点：对参数调节和核函数的选择敏感，且仅适用于二类分类</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;机器学习实战之SVM&lt;/p&gt;
&lt;p&gt;　　支持向量机这部分确实很多，想要真正的去理解它，不仅仅知道理论，还要进行相关的代码编写和测试，二者想和结合，才能更好的帮助我们理解SVM这一非常优秀的分类算法&lt;/p&gt;
&lt;p&gt;　　支持向量机是一种二类分类算法，假设一个平面可以将所有的样本分为两类，位于正侧的样本为一类，值为+1，而位于负一侧的样本为另外一类，值为-1。&lt;/p&gt;
&lt;p&gt;　　我们说分类，不仅仅是将不同的类别样本分隔开，还要以比较大的置信度来分隔这些样本，这样才能使绝大部分样本被分开。比如，我们想通过一个平面将两个类别的样本分开，如果这些样本是线性可分（或者近视线性可分），那么这样的平面有很多，但是如果我们加上要以最大的置信度来将这些样本分开，那么这样的平面只有一条。那么怎么才能找到这样的平面呢？这里不得不提到几个概念&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://hushizhi.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>港版书《你快乐所以你成功》</title>
    <link href="https://hushizhi.github.io/uncategorized/2018/01/16/%E6%B8%AF%E7%89%88%E4%B9%A6%E3%80%8A%E4%BD%A0%E5%BF%AB%E4%B9%90%E6%89%80%E4%BB%A5%E4%BD%A0%E6%88%90%E5%8A%9F%E3%80%8B.html"/>
    <id>https://hushizhi.github.io/uncategorized/2018/01/16/港版书《你快乐所以你成功》.html</id>
    <published>2018-01-16T15:45:03.000Z</published>
    <updated>2018-05-05T07:26:29.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>推荐语：成功不一定快乐，但快乐更容易成功<br>前段时间途径香港尖沙咀诚品书店，畅销书一栏处一墙畅销书，默默然拿起来这本。<br>一看书名是个很成功学的书籍，但是他的封面的简约与灵动反而更显内涵。<br>香港社会学研究很深入，而且心理学研究水平很好，姑且我相信这是一本好书。<a id="more"></a><br>内容是斯坦福大学的快乐心理学课程，主题为打破6大惯性成功迷思，化快乐为生产力。<br>大陆地区经济颇为繁华，但是有个恒久的问题就是：谁说吃苦才能让你更成功？<br>善用正念，韧性，能量管理，偷闲放空，宽容和仁慈的力量。</p><p>耐力，毅力都有非常辛苦的意思，耐力是做你不喜欢，不快乐的事，但非做不可，过程非常辛苦，需要强大的耐力支撑；毅力是去做你喜欢，快乐的事，过程也非常辛苦，但是你却不以为意。<br>正是一种这样的精神，‘成功者不一定快乐，但快乐的人却更容易成功’。我深深同意这句话。<br>当年我喜欢看《三国演义》，三四厘米厚的书，旁人会觉得，天呀，怎么看得完，但是我越看越喜欢，看了四五遍也意犹未尽。这就是快乐与成功的现实关系。<br>当人追逐金钱，权利，地位，买车买房，娶妻生子后的人生，过度的金钱与豪奢，都会让人进入另一种恶性循环，进而</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;推荐语：成功不一定快乐，但快乐更容易成功&lt;br&gt;前段时间途径香港尖沙咀诚品书店，畅销书一栏处一墙畅销书，默默然拿起来这本。&lt;br&gt;一看书名是个很成功学的书籍，但是他的封面的简约与灵动反而更显内涵。&lt;br&gt;香港社会学研究很深入，而且心理学研究水平很好，姑且我相信这是一本好书。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2018年</title>
    <link href="https://hushizhi.github.io/uncategorized/2018/01/16/2018%E5%B9%B4.html"/>
    <id>https://hushizhi.github.io/uncategorized/2018/01/16/2018年.html</id>
    <published>2018-01-16T15:26:14.000Z</published>
    <updated>2018-12-01T15:13:27.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>你好吗。很久没来这里了。最近很忙呀。<br>学车，机器学习，算法刷题，iOS实战案例操作，数据结构，毕业设计，课外书。<br>又是新的一年。爸妈老了一岁。自己又大了一岁。世界还是在变化。<br>跟小女友的关系也越来越好。了解得越来越深。越来越有默契。也越来越来愿景。越来越温馨。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;你好吗。很久没来这里了。最近很忙呀。&lt;br&gt;学车，机器学习，算法刷题，iOS实战案例操作，数据结构，毕业设计，课外书。&lt;br&gt;又是新的一年。爸妈老了一岁。自己又大了一岁。世界
      
    
    </summary>
    
    
  </entry>
  
</feed>
